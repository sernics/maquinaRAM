# Cargamos lo necesario
LOAD =1         # Cargamos el valor 1 en R0 (para uso general)
STORE 1         # Almacenamos el valor 1 en la memoria en la posición 1 (para uso general)
LOAD =1         # Cargamos el valor 1 en R0 (para uso general)
STORE 2         # Almacenamos el valor 1 en la memoria en la posición 2 (para uso general)
LOAD =2         # Cargamos el valor 2 en R0 (para uso general)
STORE 3         # Almacenamos el valor 2 en la memoria en la posición 3 (para uso general)

for_i:                                  
    LOAD 2          # Cargamos el valor de la posición 2 en R0 (valor de i)
    SUB 1           # Restamos 1 a R0 (i - 1)
    JZERO end_sort # Si R0 es 0, salimos del bucle principal

    LOAD 3          # Cargamos el valor de la posición 3 en R0 (valor de j)
    LOAD 1          # Cargamos el valor de la posición 1 en R0 (valor de n)
    SUB 2           # Restamos 1 a R0 (n - 1)
    SUB =1          # Restamos 1 a R0 (n - 2)
    JZERO end_for_i # Si R0 es 0, salimos del bucle interno

    LOAD 3          # Cargamos el valor de la posición 3 en R0 (valor de j)
    LOAD 1          # Cargamos el valor de la posición 1 en R0 (valor de n)
    SUB 2           # Restamos 1 a R0 (n - 1)
    SUB =1          # Restamos 1 a R0 (n - 2)
    STORE 4         # Almacenamos el valor de (n - j) en la posición 4 (para uso general)

for_j:                                      
    LOAD 4          # Cargamos el valor de la posición 4 en R0 (valor de n - j)
    JZERO end_for_j # Si R0 es 0, salimos del bucle interno

    LOAD 4          # Cargamos el valor de la posición 4 en R0 (valor de n - j)
    LOAD 1          # Cargamos el valor de la posición 1 en R0 (valor de n)
    SUB 2           # Restamos 1 a R0 (n - 1)
    SUB =1          # Restamos 1 a R0 (n - 2)
    STORE 5         # Almacenamos el valor de (n - j - 1) en la posición 5 (para uso general)

    LOAD R1[*5]     # Cargamos el valor de A[j-1] en R0
    SUB =1          # Restamos 1 a R0 (A[j-1] - 1)
    STORE 6         # Almacenamos el valor de (A[j-1] - 1) en la posición 6 (para uso general)

    LOAD R1[*5]     # Cargamos el valor de A[j-1] en R0
    STORE 7         # Almacenamos el valor de A[j-1] en la posición 7 (temporal)

    LOAD R1[*6]     # Cargamos el valor de (A[j-1] - 1) en R0
    STORE R1[*5]    # Almacenamos el valor de (A[j-1] - 1) en la posición A[j]

    LOAD 7          # Cargamos el valor temporal en R0
    STORE R1[*6]    # Almacenamos el valor temporal en la posición A[j-1]

    LOAD 4          # Cargamos el valor de la posición 4 en R0 (valor de n - j)
    SUB =1          # Restamos 1 a R0 (n - j - 1)
    STORE 4         # Almacenamos el valor de (n - j - 1) en la posición 4 (actualización de n - j)

    JUMP for_j      # Volver al inicio del bucle interno

end_for_j:                            
    LOAD 3          # Cargamos el valor de la posición 3 en R0 (valor de j)
    ADD =1          # Añadimos 1 a R0 (j + 1)
    STORE 3         # Almacenamos el valor de (j + 1) en la posición 3 (actualización de j)
    JUMP for_i      # Volver al inicio del bucle principal

end_for_i:
    LOAD 2          # Cargamos el valor de la posición 2 en R0 (valor de i)
    SUB =1          # Restamos 1 a R0 (i - 1)
    STORE 2         # Almacenamos el valor de (i - 1) en la posición 2 (actualización de i)
    JUMP for_i      # Volver al inicio del bucle principal

end_sort:
    HALT            # Detener la ejecución del programa
